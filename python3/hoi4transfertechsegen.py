#!/usr/bin/env python3
"""Generate or extend a HoI4 transfer technology scripted effect."""

import argparse
import datetime as dt
import re
import shutil
from pathlib import Path
from typing import Iterable, List

TECH_ENTRY_REGEX = re.compile(r"has_tech\s*=\s*(\w+)")
COMMENT_MARKER = (
    "### Automatically generated by Yard1's transfer_technology generator, "
    "originally for Equestria at War"
)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Given a technology file or directory, generate a scripted effect "
            "that transfers researched technologies from PREV to ROOT."
        )
    )
    parser.add_argument(
        "input",
        type=Path,
        help="Technology file or directory containing technology files",
    )
    parser.add_argument(
        "output",
        type=Path,
        help="Output file for the scripted effect",
    )
    parser.add_argument(
        "-en",
        "--effectname",
        default="transfer_technology",
        help="Name of the scripted effect (default: transfer_technology)",
    )
    action = parser.add_mutually_exclusive_group()
    action.add_argument(
        "-a",
        "--add",
        action="store_true",
        help="Append technologies to an existing effect (requires output file)",
    )
    action.add_argument(
        "-o",
        "--overwrite",
        action="store_true",
        help="Overwrite the output file if it already exists",
    )
    return parser.parse_args()


def read_lines_with_fallback(path: Path) -> List[str]:
    encodings = ("utf-8", "utf-8-sig", "cp1252")
    for encoding in encodings:
        try:
            return path.read_text(encoding=encoding).splitlines()
        except UnicodeDecodeError:
            continue
    raise SystemExit(f"Could not decode '{path}' using UTF-8 or CP1252.")


def collect_tech_files(path: Path) -> Iterable[Path]:
    if path.is_dir():
        yield from sorted(child for child in path.glob("*.txt") if child.is_file())
    else:
        yield path


def read_technology_names(path: Path) -> List[str]:
    names: list[str] = []
    lines = read_lines_with_fallback(path)
    open_blocks = 0
    inside_tech = False
    for raw_line in lines:
        line = re.sub(r"#.*", "", raw_line)
        if not inside_tech and "technologies = {" in line:
            inside_tech = True
        if inside_tech and open_blocks == 1 and "{" in line:
            name = re.sub(r"\s|=(\s|){", "", line)
            if name and name not in names:
                names.append(name)
        open_blocks += raw_line.count("{")
        open_blocks -= raw_line.count("}")
    return names


def gather_names(input_path: Path) -> List[str]:
    names: list[str] = []
    for tech_file in collect_tech_files(input_path):
        if not tech_file.exists():
            raise SystemExit(f"Technology file '{tech_file}' was not found.")
        print(f"Reading file {tech_file}...")
        found = read_technology_names(tech_file)
        if found:
            print(f"File {tech_file} read successfully!")
            names.extend(found)
        else:
            print(f"File {tech_file} is not a valid technology file, skipping.")
    unique_names = list(dict.fromkeys(names))
    if not unique_names:
        raise SystemExit("No technology names were discovered; nothing to generate.")
    return unique_names


def build_effect_entries(names: Iterable[str]) -> List[str]:
    lines: list[str] = []
    for name in names:
        lines.extend(
            [
                "",
                "\t\tif = {",
                "\t\t\tlimit = {",
                "\t\t\t\tPREV = {",
                f"\t\t\t\t\thas_tech = {name}",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t\tset_technology = {",
                f"\t\t\t\t{name} = 1",
                "\t\t\t}",
                "\t\t}",
            ]
        )
    return lines


def build_full_effect(effect_name: str, names: Iterable[str]) -> List[str]:
    now = dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = [
        "### DO NOT REMOVE OR CHANGE THE COMMENTS BELOW",
        f"### Transfer Technology Effect ({effect_name})",
        COMMENT_MARKER,
        f"### File last modified: {now}",
        "### PREV is the giver, THIS is the receiver",
        f"{effect_name} = {{",
        "\thidden_effect = {",
    ]
    footer = ["\t}", "}"]
    return header + build_effect_entries(names) + footer


def backup_file(path: Path) -> None:
    backup = path.with_suffix(path.suffix + ".bak")
    try:
        backup.unlink()
    except FileNotFoundError:
        pass
    shutil.copy2(path, backup)
    print(f"Backup created at {backup}.")


def extract_existing_names(lines: List[str]) -> set[str]:
    names = set()
    for line in lines:
        match = TECH_ENTRY_REGEX.search(line)
        if match:
            names.add(match.group(1))
    return names


def update_timestamp(lines: List[str]) -> None:
    now_line = f"### File last modified: {dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    for index, line in enumerate(lines):
        if line.startswith("### File last modified:"):
            lines[index] = now_line
            break


def find_hidden_effect_bounds(lines: List[str]) -> tuple[int, int]:
    for index, line in enumerate(lines):
        if "hidden_effect" in line and "{" in line:
            depth = line.count("{") - line.count("}")
            current = index + 1
            while depth > 0 and current < len(lines):
                depth += lines[current].count("{")
                depth -= lines[current].count("}")
                current += 1
            return index, current - 1
    raise SystemExit("Existing file does not contain a hidden_effect block to extend.")


def write_lines(path: Path, lines: List[str]) -> None:
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main() -> None:
    args = parse_args()

    names = gather_names(args.input)
    output_exists = args.output.exists()

    if output_exists and not (args.add or args.overwrite):
        raise SystemExit(
            f"File {args.output} already exists. Use --overwrite to replace or --add to append."
        )
    if args.add and not output_exists:
        raise SystemExit("--add requires an existing output file to append to.")

    if args.add:
        lines = read_lines_with_fallback(args.output)
        if COMMENT_MARKER not in "\n".join(lines):
            raise SystemExit(
                f"File {args.output} does not appear to be a valid generated file."
            )

        existing = extract_existing_names(lines)
        new_names = [name for name in names if name not in existing]
        if not new_names:
            raise SystemExit(
                f"Nothing to add - every technology is already in {args.output}."
            )

        backup_file(args.output)
        update_timestamp(lines)
        _, end = find_hidden_effect_bounds(lines)
        entries = build_effect_entries(new_names)
        lines[end:end] = entries
        write_lines(args.output, lines)
        print(f"Added {len(new_names)} technologies to {args.output}.")
        return

    if output_exists:
        backup_file(args.output)
    effect_lines = build_full_effect(args.effectname, names)
    write_lines(args.output, effect_lines)
    print(f"Written to {args.output} successfully!")
    print(f"Added {len(names)} technologies.")


if __name__ == "__main__":
    main()
